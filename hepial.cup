import java_cup.runtime.*;
import java.util.Vector;
import java.io.*;
import java.util.*;
import java.lang.*;
import ch.hepia.Arbre.*;
import ch.hepia.TDS.*;
import ch.hepia.Types.*;

// Initializing
parser code {:
	SymbolTable TDS;
	public Type lastType;
	public String lastId;
	public PileArbre stack = new PileArbre();
:}

terminal DEBUTPRG, FINPRG, PROG, POINTVIRGULE, VIRGULE, CONSTANTE, EGAL, PARENTHESEOUVERT, PARENTHESEFERME, DEBUTFONC, FINFONC;
terminal ENTIER, BOOLEEN, CROCHETOUVERT, CROCHETFERME, RANGE, LIRE, ECRIRE, A, VRAI, FAUX, FOIS, DIVISE, PLUS, MOINS;
terminal PLUSGRAND, PLUSPETIT, PLUSGRANDEGAL, PLUSPETITEGAL, ET, OU, EGALITE, DIFFERENCE, NON, TILDE, RETOURNE, SI, ALORS;
terminal SINON, FINSI, TANTQUE, POUR, FAIRE, FINTANTQUE, ALLANTDE, FINPOUR;
terminal int CONSTANTEENT;
terminal String IDENTIFICATOR;
terminal String CONSTANTECHAINE;

non terminal axiome, programme, entete, decla, declavar, declaconst, declafonct;
non terminal typebase, tableau, param, corps, instr, lire, ecrire, affectation, retour;
non terminal condition, tantque, pour, expr, acces, index, operande, opebin, opeun, appelfct, pareff;
non terminal dim;
non terminal ArrayList<String> lident;
non terminal Type type;

precedence left PLUS, MOINS, FOIS ,DIVISE, EGALITE, DIFFERENCE;
precedence left PLUSGRAND, PLUSPETIT, PLUSGRANDEGAL, PLUSPETITEGAL, ET, OU, RANGE;
precedence right TILDE, NON;

axiome ::= programme;

programme ::= entete DEBUTPRG corps FINPRG;

programme ::= entete decla DEBUTPRG corps FINPRG;

entete ::= PROG IDENTIFICATOR
{:
	TDS.getInstance().openBlock();
	stack.push(new Bloc(0));
:}
;

decla ::= declavar
        | declaconst
        | declafonct
        | decla declavar
        | decla declaconst
        | decla declafonct
;

declavar ::= type:type lident:id_list POINTVIRGULE
{:
  for (String id : id_list) {
		TDS.getInstance().add(id, new Symbole(lastType, id_listright));
    System.out.println(id+": "+lastType.toString() + " => " + TDS.getInstance().getCurrentBlock());
	}
:}
;

declaconst ::= CONSTANTE type affectation
{:
	TDS.getInstance().add(lastId, new Symbole(lastType, 1));
	System.out.println(lastId+": "+lastType.toString() + " => " + TDS.getInstance().getCurrentBlock());
:}
;

declafonct ::= type IDENTIFICATOR:id
/*{:
	TDS.getInstance().add(id, new Symbole(lastType, idright));
	System.out.println("line " + idright + " " +id+": "+lastType.toString() + " => " + TDS.getInstance().getCurrentBlock());
:}*/
PARENTHESEOUVERT PARENTHESEFERME decla DEBUTFONC corps FINFONC
             | type IDENTIFICATOR:id
/*{:
	TDS.getInstance().add(id, new Symbole(lastType, idright));
  	System.out.println("line " + idright + " " +id+": "+lastType.toString() + " => " + TDS.getInstance().getCurrentBlock());
:}*/
PARENTHESEOUVERT param PARENTHESEFERME decla DEBUTFONC corps FINFONC;

lident ::= IDENTIFICATOR:id
{:
  ArrayList<String> id_list = new ArrayList<String>();
  id_list.add(id);
  RESULT = id_list;
:}
          | lident:id_list VIRGULE IDENTIFICATOR:id
{:
  id_list.add(id);
  RESULT = id_list;
:}
;

type ::= typebase | tableau;

typebase ::= ENTIER
{:
  lastType = TypeEntier.getInstance();
:}
| BOOLEEN
{:
  lastType = TypeBooleen.getInstance();
:}
;

tableau ::= typebase CROCHETOUVERT dim CROCHETFERME
;

dim ::= expr RANGE expr
      | dim VIRGULE expr RANGE expr;

param ::= type IDENTIFICATOR
        | param VIRGULE type IDENTIFICATOR;

//todo finish grammar
corps ::= instr
        | instr corps;

instr ::= affectation
        | ecrire
        | lire
        | condition
        | retour
        | tantque
        | pour;

lire ::= LIRE IDENTIFICATOR POINTVIRGULE;

ecrire ::= ECRIRE expr POINTVIRGULE
         | ECRIRE CONSTANTECHAINE POINTVIRGULE;

affectation ::= acces EGAL expr POINTVIRGULE
{:
	Expression source = (Expression) (stack.pop());
	Idf dest = (Idf) (stack.pop());
	Bloc bloc = (Bloc) (stack.pop());
	Affectation affect = new Affectation(source, dest, 1);
	System.out.println(affect);
	bloc.add(affect);
	stack.push(bloc);
:}
;

retour ::= RETOURNE expr POINTVIRGULE;

condition ::= SI expr ALORS {: System.out.println("pushed bloc"); stack.push(new Bloc(1)); :} corps SINON {: System.out.println("pushed bloc"); stack.push(new Bloc(1)); :} corps FINSI
{:
	Bloc sinon = (Bloc) stack.pop();
	Bloc alors = (Bloc) stack.pop();
	Expression cond = (Expression) stack.pop();
	Bloc b = (Bloc)stack.pop();
	b.add(new Condition(cond, alors, sinon, 1));
	stack.push(b);
:}
;

tantque ::= TANTQUE expr FAIRE {: System.out.println("pushed bloc"); stack.push(new Bloc(1)); :} corps FINTANTQUE
{:
	Bloc boucle = (Bloc) stack.pop();
	Expression cond = (Expression) stack.pop();
	Bloc b = (Bloc)stack.pop();
	b.add(new Tantque(cond, boucle, 1));
	stack.push(b);
:}
;

pour ::= POUR IDENTIFICATOR ALLANTDE expr A expr FAIRE {: System.out.println("pushed bloc"); stack.push(new Bloc(1)); :} corps FINPOUR
{:
	Bloc boucle = (Bloc) stack.pop();
	Expression BorneSup = (Expression) stack.pop();
	Expression BorneInf = (Expression) stack.pop();
	Idf ident = (Idf) stack.pop();
	Bloc b = (Bloc)stack.pop();
	b.add(new Pour(ident, BorneInf, BorneSup, boucle, 1));
	stack.push(b);
:}
;

expr ::= expr opebin expr
{:
	Expression exprd = (Expression)stack.pop();
	Binaire opebin = (Binaire)stack.pop();
	Expression exprg = (Expression)stack.pop();
	opebin.setOperandeDroite(exprd);
	opebin.setOperandeGauche(exprg);
	stack.push(opebin);
	System.out.println(opebin);
:}
      |  opeun expr
      |  PARENTHESEOUVERT expr PARENTHESEFERME
      |  operande;

acces ::= IDENTIFICATOR:id
{:
	lastId = id;
	stack.push(new Idf(id, 1));
:}
        | IDENTIFICATOR index;

index ::= CROCHETOUVERT expr CROCHETFERME
        | CROCHETOUVERT expr CROCHETFERME index;

operande ::= acces
          |  appelfct
          |  CONSTANTEENT:constante
{:
	System.out.println("pushed " + constante);
	stack.push(new Nombre(constante, 1));
:}
          |  VRAI
          |  FAUX;

opebin ::= PLUS {: stack.push(new Addition(1)); :}
        |  MOINS {: stack.push(new Soustraction(1)); :}
        |  DIVISE {: stack.push(new Division(1)); :}
        |  FOIS {: stack.push(new Produit(1)); :}
        |  EGALITE {: stack.push(new Egal(1)); :}
        |  DIFFERENCE {: stack.push(new Different(1)); :}
        |  PLUSPETIT {:	stack.push(new Inferieur(1)); :}
        |  PLUSGRAND {: stack.push(new Superieur(1)); :}
        |  PLUSGRANDEGAL {:	stack.push(new SupEgal(1)); :}
        |  PLUSPETITEGAL {: stack.push(new InfEgal(1)); :}
        |  ET {: stack.push(new Et(1)); :}
        |  OU {: stack.push(new Ou(1)); :}
;

opeun ::= TILDE
        | NON;

appelfct ::= IDENTIFICATOR PARENTHESEOUVERT PARENTHESEFERME
          |  IDENTIFICATOR PARENTHESEOUVERT pareff PARENTHESEFERME;

pareff ::= expr
        |  pareff VIRGULE expr;
